# tracking_GUI
Program suite in Matlab for tracking and analysing single-molecule fluorescence assays on molecular motors.

This software was developed during a PhD project at E22 physics department of the Technical University of Munich by Willi L. Stepp.

The parfor_progress package might be needed 
https://de.mathworks.com/matlabcentral/fileexchange/32101-progress-monitor-progress-bar-that-works-with-parfor

Here are the Toolboxes etc the software has been used with
'9.5'	'MATLAB'
'10.3'	'Image Processing Toolbox'
'11.4'	'Statistics and Machine Learning Toolbox'
'3.5.8'	'Curve Fitting Toolbox'
'6.13'	'Parallel Computing Toolbox'
'6.13'	'MATLAB Distributed Computing Server'

This is an excerpt from my PhD thesis describing the capabilities of the software suite:

This chapter will summarize the function of 2126 lines of code developed over a couple of years. A working version of this software and the respective files will be available at \url{github.com/wl-stepp/tracking_GUI}. This version was last tested under Matlab R2018b and used for \cite{Stepp2017,Stepp2019,Mohamed2018,Oberhofer2017} and at least two more papers from our lab that are close to or already submitted by July 2019. As the algorithm we use is described only very briefly in the publications, I will describe the software and the interface in some more detail here. 

The core of the program is meant for the analysis of single-molecule assays of molecular motors walking on surface attached filaments. The two main parameters that can be extracted are the speed and run-length of the motors. The detected runs however are also used for co-localization, step detection and diffusion analysis. It is optimized for minimum input of user-defined parameters aiming to reduce the experiment conductors bias into the data. Also, the shear amount of data analyzed in the last years in our lab would not have been possible by analyzing the data 'by hand'.

\subsection*{Basic capabilities and file compatibility}
The software has been used in our lab for processive kinesin and myosin motors. The speed range it was tested in is \newtexttilde\SI{50}{\nano\meter\per\second} to \newtexttilde\SI{2}{\micro\meter\per\second}. The fits for run-lengths are realized in a way, that allows the fitting below the cut-off at \SI{1}{\micro\meter} (Supplementary Figure \ref{fig_app:rl_fits}). Nevertheless, run-length that have been tested lie between \SI{0.7}{\micro\meter} and \SI{4}{\micro\meter}. There is a main limitation to the minimum run-length being at least \SI{5}{\frames} of movement and thus depending on the speed of the motor due to the algorithm for speed calculation explained later. A lot of files could potentially be programmed for input, as the bio-formats package is used for this \cite{Linkert2010}. In the current state import is implemented for .sif (Andor), .lif (Leica) and .tif files. Meta data (cycle time and pixel to distance conversion) is imported from .sif and .lif files according to the respective companies guidelines. I also implemented a meta data environment for the tif files that is used by the FIONA-setup software described above. Specifics can be found in the get\_meta\_data.m file. Files should always be stacks of images. One out of multiple series inside one lif file can be chosen upon file choice. If multiple channels are present in a .lif file they can be separated using the multi\_color mode.

\subsection*{Data import and user-set parameters}
The data is imported into a Matlab 3D matrix and can be 'played' using the slider under the image (Figure \ref{fig_app:tracking_GUI} middle). A simple contrast algorithm based on percentage of brightest/darkest pixel sets the contrast and brightness of the image without user input. This allows a first unbiased assessment of the signal to noise ratio of the data. The first user input is then the 'dotsize', meaning the size of the square around a bright pixel that is used to interpret the motors position. This also has implications for the minimum distance between peaks, detailed later. The second user input is the signal-to-noise ratio of the peaks that should be evaluated. This can also be set by the vertical sliders. The simple 'as high as necessary, as low as possible' rule applies for the minimal signal-to-noise ratio setting. It should be high enough to not include any bright pixels in the noise but low enough to also accommodate fluctuations in the peak brightness from frame to frame. Overall, the better the signal-to-noise ratio in the data, the easier it is to find good settings for these parameters. If using a file without meta data, the pixel conversion (in \SI{}{\micro\meter\per\pixel}) and cycle time (in \SI{}{\second}) has to be set in the 'Info' tab on the right.

\subsection*{Detection of relevant peaks and sub-pixel position}
The procedure for analysis is split into three stages, which allows assessment of intermediate results before further steps. The 'dots' button starts the search for relevant peaks in the field of view using the choose\_noise\_factor\_tracking\_v3.m function. A list of the pixels is ordered from the brightest pixel to the darkest. The noise level in the image is approximated by the mean intensity in the image. All peaks that have a higher ratio of brightest pixel over noise level than the set 'signal-to-noise ratio' (snr) are analyzed. A for loop starts at the brightest pixel and extracts a square the size of 'dotsize' from the frame. This prevents the repeated analysis of peaks that have many bright pixels. In this square, a test ensures, that the peak is still a bright spot in its immediate surrounding by comparing the mean brightness in the square with the mean brightness in a \SI{2}{\pixel} wide halo around the square. Next, the distances to the next already analyzed peak and the borders of the frame are measured. If these parameters fit a list of requirements (surrounding-factor $> 0.1*(snr - 1) + 1$, next-peak distance \textgreater{} dotsize, border distance \textgreater{} \SI{2}{\pixel}) a sub-pixel accuracy position of the peak is determined. In the normal mode, a radial center approach is used to do this due to its superior calculation time \cite{Parthasarathy2012}. If the 'FIONA mode' is activated, this step is done by fitting a 2D gaussian profile to the data in the specified square. This yields the more accurate data for stepping analysis but is very time consuming and not necessary for speed and run-length analysis. If the sub-pixel position of the motor is determined successfully, the acquired data is written into the peakvalues cell type variable:\newline
peakvalues\{frame\}(i,peak\_number)\newline
i:\newline
1 signal-to-noise ratio\newline
2 sub-pixel x position\newline
3 sub-pixel y position\newline
4 peak\_ID used for later sorting\newline
5 used for later proximity data\newline
6 later for distance to first peak in run\newline
7 frame\newline
8 total brightness\newline
This leads to a list of all relevant peaks and their properties for each frame of the stack. These are indicated by open circles in the user interface. The user should now assess the result by checking if the desired peaks are actually tracked and adjust the input parameters if necessary.

This procedure is run for each frame independently and can therefore be parallelized. Even though Matlab is good at allocating CPU threads, even better performance was observed when using a parfor loop. A performance increase of \newtexttilde\num{0.7} times the number of cores is typically observed. The parfor integration also allows running the code on a external cluster, a function not tested thoroughly so far. 

\subsection*{Construction of runs by frame-to-frame analysis}
Peaks have to be followed now from frame to frame (pic\_by\_pic button and pic\_by\_pic.m function). This procedure is actually vectorized in the code in order to enhance the performance, but I will describe the classic approach here, as vectorized code is very non-intuitive (see \url{www.mathworks.com/help/matlab/matlab_prog/vectorization.html} for more details). The pairwise distance of peaks is calculated frame-to-frame. A cycle through all the peaks detects the closest peak in the next frame to the reference peak. It is also checked, that this peak is not closer to any other peak in the current frame by first calculating all the distances. If this peak is closer than the dotsize, it is appended to the current run and excluded from further analysis. If a peak is not close enough to any peak in the previous frame, it gets a new run ID and can initiate a new run. This leads to a cell structure of runs, with each run being a list of data from the peakvalues cell with the data specified above. With the 'mark all traces' option selected the user can now assess if all desired runs are detected. If runs are interrupted, the snr can be lowered and the data should be checked for blinking of the fluorophores.

As each instance of the for loop needs the data from two frames, the performance benefit of parallelization depends on the capability of the system to handle overhead in the memory.

\subsection*{Calculation of speeds and run-lengths}
For speed calculation, the distance of all peaks in a run to the initial position are calculated. The run-length of the run is the maximal distance to the start position in this data. Speed calculation is performed on the distance-time data by fitting lines to parts of the data as follows. Starting from the first \num{6} data points, a linear regression is performed. Additional data points are added to the fit as long as the fit achieves the minimum r-squared value of \SI{95}{\percent}. If this criterion is not met, the current speed measurement is terminated and the last good fit parameters are saved. The next speed measurement is initiated as before from the next point after the previous measurement. If a speed was calculated for more than one part of the run, the overall speed is calculated as the mean of all fits. The obtained data can be plotted from the software directly into histograms or exported into a comma-separated values format and .mat files. This procedure runs independently for each run and could therefore be parallelized with high efficiency.

\subsection*{Further analysis of the runs}
The runs obtained from tracking can also be used for further analysis. At limiting ATP-concentrations and using the 'FIONA mode', the function kinesin\_step\_detection\_v2 pulls the data from a current run in the tracking software directly and performs step detection and analysis. The functions colocalize\_runs\_vX work on exported .mat files that contain all runs in two channels. The algorithm detects runs that are very close in the space and time domain and allows to estimate the percentage of runs that are observed in both channels. If the motors show diffusive behavior and the 'Diffusion mode' is used, the function batch\_msd\_from\_traces calculates the mean square displacement of the diffusion behavior and additional parameters.

